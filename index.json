[
{
	"uri": "https://atom-haskell.github.io/installation/installing-packages/",
	"title": "Installing packages",
	"tags": [],
	"description": "",
	"content": " Refer to Atom Flight Manual section on packages for more detailed information\n You can find a complete list of Atom-Haskell packages on atom.io package registry\n There are binary dependencies which are not touched upon in this section. Refer to next section for a guide.\n Pick-and-choose approach You can pick and choose what packages you want and do not want to install. However, bear in mind that language-haskell is absolutely mandatory, and ide-haskell is most likely required too.\nMost people would want at least core Atom-Haskell packages, which can be installed with a simple apm (Atom Package Manager) command. From terminal, run:\napm install language-haskell ide-haskell ide-haskell-cabal haskell-ghc-mod autocomplete-haskell  You can install other packages on case-by-case basis.\nWhole bundle approach There\u0026rsquo;s a community bundle that automatically installs most Atom-Haskell packages and a few extras.\nYou can find it at https://atom.io/packages/atom-haskell\nSince this is a community package, it is not directly supported by Atom-Haskell.\n "
},
{
	"uri": "https://atom-haskell.github.io/core-packages/language-haskell/",
	"title": "Language-Haskell",
	"tags": [],
	"description": "",
	"content": " Language-Haskell adds syntax highlighting and snippets to Haskell files in Atom.\nAuto-indent If you don\u0026rsquo;t like current auto-indentation settings, you can define your own regular expression in config.cson (Edit -\u0026gt; Open Your Config), or disable it altogether.\nAtom is using oniguruma for regular expression, and, as such, expressionhas to be a string, not a javascript regexp. You\u0026rsquo;ll also have to escape \\.\n To disable auto-indent:\n\u0026quot;.haskell.source\u0026quot;: editor: increaseIndentPattern: ''  By default, increaseIndentPattern has the following value:\n\u0026quot;.haskell.source\u0026quot;: editor: increaseIndentPattern: '(((=|\\\\bdo|\\\\bwhere|\\\\bthen|\\\\belse|\\\\bof)\\\\s*)|(\\\\bif(?!.*\\\\bthen\\\\b.*\\\\belse\\\\b.*).*))$'  Configuring highlighting You may need to reopen currently opened files (or restart Atom) for your new stylesheet to be applied.\n Module names language-haskell uses support.other.module.haskell scope for module names, both in import statements and when using qualified identifiers (like Prelude.foldl). Your syntax theme might not support this scope. If you want to highlight module names in this case, you can add the following to your stylesheet (Edit → Stylesheet\u0026hellip;):\n.syntax--support.syntax--other.syntax--module.syntax--haskell { color: #C0A077; //or whatever color you like }  Operators and infix function application language-haskell uses keyword.operator.haskell scope for operators and keyword.operator.infix.haskell for infix function application, e.g.\nnegate `map` [1..10]  Not all syntax themes support these scopes (almost none support keyword.operator.infix particularly)\nIf you want to higlight operators and infix function applications you can add the following to your stylesheet (Edit → Stylesheet\u0026hellip;):\n.syntax--keyword.syntax--operator.syntax--haskell { color: #CF8C00; // or whatever color you like } .syntax--keyword.syntax--operator.syntax--infix.syntax--haskell { color: #CC77AC; // if you want to highlight infix application differently }  Special Prelude treatment For historical and other reasons (see #85 for discussion), Prelude identifiers (functions, types, etc) are treated slightly differently and, depending on your highlighting theme, can be highlighted differently.\nScopes that are used:\n support.function.prelude.haskell for functions and values support.class.prelude.haskell for types entity.other.inherited-class.prelude.haskell for typeclasses support.tag.prelude.haskell for type constructors  If you want Prelude identifiers highlighted differently from all the rest, you can define different colors for all or some of those, f.ex. by adding something like this to your stylesheet (Edit → Stylesheet\u0026hellip;):\n.syntax--support.syntax--function.syntax--prelude.syntax--haskell { color: #56b6c2; // or whatever color you like } .syntax--support.syntax--tag.syntax--prelude.syntax--haskell { color: #e9969d; }  If you don\u0026rsquo;t want Prelude identifiers highlighted differently, you can override it by adding something like this to your stylesheet (Edit → Stylesheet\u0026hellip;):\n.syntax--prelude.syntax--haskell { color: inherit; }  "
},
{
	"uri": "https://atom-haskell.github.io/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": " Chapter I Overview  Features     Requirements     "
},
{
	"uri": "https://atom-haskell.github.io/",
	"title": "Atom-Haskell documentation",
	"tags": [],
	"description": "",
	"content": " Atom-Haskell documentation Welcome to Atom-Haskell documentation site.\nInformation collected on these pages should help you get started with Haskell in Atom editor.\nClick one of the links on the left to start reading.\nIRC Chat You can join #atom-haskell on FreeNode, and devs can usually be found there. Bear in mind that if someone\u0026rsquo;s on the channel, it doesn\u0026rsquo;t necessarily mean they aren\u0026rsquo;t AFK.\nIf you\u0026rsquo;re not familiar with IRC, you can use FreeNode\u0026rsquo;s webchat\nGitter Chat We also have a Gitter chat room on https://gitter.im/atom-haskell/ide-haskell\n"
},
{
	"uri": "https://atom-haskell.github.io/overview/features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": " Sytnax highlighting Grammars:\n Haskell (*.hs) Literate Haskell (*.lhs) Cabal (*.cabal)  Errors, warnings and lints After saving the current file the check and linter processes will be executed. After processes are finished, the results can be seen in output panel. You can see different kind of results by switching Errors, Warnings and Lints tab buttons. If you click on message\u0026rsquo;s file name in output panel, Atom will open this file and put cursor near problem that triggered output message.\nCheck results can also be seen in left editor gutter (near line numbers) as icons. If you hover mouse pointer over such an icon, a tooltip will be shown with problem description. Results are highlighted inside editor as well, so you can easily determine where the problem is.\nGet type/info If you have haskell-ghc-mod or similar package installed, you can get type of any expression and get info on any symbol.\nThere are two options to do so.\nFirst one is to hover mouse pointer over any Haskell source in editor, or any selection. By default, this will show type for expression/selecton under cursor. You can change this behavior to show info for symbol, or disable it completely in IDE-Haskell settings.\nAnother option is to use keyboard to get type/info under cursor. No default bindings are specified, but you can specify them in your Atom keymap.\nSee Configuration for more information.\nAutocompletion You can show auto-completions for hole _. This will try to find replacements based on type. It\u0026rsquo;s no magic though, so if hole has some crazy type, it won\u0026rsquo;t find anything. You can also refine hole completions based on name by using named holes, e.g. _from\nCurrent autocompletion scopes:\n Import module name Import module symbols Language pragmas OPTIONS_GHC pragma Type name Class name Symbol name  Autocompletion:\nImport autocompletion:\nHole autocompletion:\nCode beautify You can use prettifier filter programs, such as stylish-haskell, hindent and brittany. Simply select Prettify from Haskel IDE menu to apply prettifier to current file, or choose to prettify on each save.\nBuild and test project If you have ide-haskell-cabal or similar package installed, you can build, clean and test your project from ide-haskell (stack and cabal supported)\n"
},
{
	"uri": "https://atom-haskell.github.io/core-packages/ide-haskell/",
	"title": "IDE-Haskell",
	"tags": [],
	"description": "",
	"content": " IDE-Haskell Atom package provides basic capabilities, as well as a backend for other Atom-Haskell packages to use.\nKnown conflicts This package relies on grammar defined by language-haskell. Any other Haskell grammar packages (such as haskell-grammar) may conflict with it.\nConfiguration Package is fully configurable via Edit → Preferences → Packages → ide-haskell → Settings\nYou will likely need to specify full path to prettifier executable, at the very least.\nYou might also want to look into configuring haskell-ghc-mod and ide-haskell-cabal\nSince version 1.0.0, some configuration options have been moved to backends, in particular, haskell-ghc-mod. Migration should be automatic, but please check if your configuration is correct just in case.\n Keyboard shortcuts Since version 1.0.0, most commands are provided by backends, in particular, haskell-ghc-mod and ide-haskell-cabal. Please revise your keymap accordingly.\n Refer to sections on haskell-ghc-mod and ide-haskell-cabal for details\nIde-Haskell comes with little pre-specified keybindings, so you will need to specify your own, if you want those.\nYou can edit Atom keybindings by opening \u0026lsquo;Edit → Open Your Keymap\u0026rsquo;. Here is a template for all commands, provided by ide-haskell:\n'atom-text-editor.ide-haskell--has-tooltips': 'escape': 'ide-haskell:close-tooltip' #this is set by default 'atom-text-editor.ide-haskell': '':'ide-haskell:prettify-file' 'atom-workspace': '': 'ide-haskell:toggle-output' '': 'ide-haskell:next-error' '': 'ide-haskell:prev-error'  Changing output panel look Changing output panel look can be achieved with Atom stylesheets. You can open your stylesheet with Edit → Stylesheet\u0026hellip;\nSyntax is Less. You can use the following selectors:\n ide-haskell-panel \u0026ndash; whole panel ide-haskell-panel-heading \u0026ndash; panel heading (control elements) ide-hashell-panel-items \u0026ndash; output area ide-haskell-item-position \u0026ndash; file/line/column of individual message ide-haskell-item-description \u0026ndash; message itself  Please note, that to change font face in ide-haskell-item-description, you need to target it specifically, or use !important specifier.\nFor example, to change font size in whole panel:\nide-haskell-panel { font-size: 18pt; }  Or only in output area:\nide-haskell-panel-items { font-size: 18pt; }  To change font face in panel heading:\nide-haskell-panel-heading { font-family: \u0026quot;Comic Sans MS\u0026quot;; }  To change font face in messages themselves:\nide-haskell-item-description { font-family: \u0026quot;Fira Mono\u0026quot;; }  You are free to write any CSS, of course. Bear in mind, however, that any selectors not listed above are subject to sudden change.\nUsing atom-linter for output You can use linter package for displaying some messages. Install linter package, and then change messageDisplayFrontend in ide-haskell settings to linter. Restart Atom.\nAdvanced configuration (since v2.2.0) Some ide-haskell settings are root scope-sensitive, meaning they can have different values defined in config depending on editor grammar.\nAtom Flight Manual gives a brief introduction into scoped settings here, but here\u0026rsquo;s a short refresher.\nYou can define setting overrides in your config file (Edit → Config\u0026hellip;) under specific scope selectors. For example, imagine this is your config:\n\u0026quot;*\u0026quot;: \u0026quot;ide-haskell\u0026quot;: stylishHaskellPath: \u0026quot;stylish-haskell\u0026quot;  Now, consider you would like to use hindent, but only for Literate Haskell files (since stylish-haskell doesn\u0026rsquo;t support lhs). You can do that by extending your config like so:\n\u0026quot;*\u0026quot;: \u0026quot;ide-haskell\u0026quot;: stylishHaskellPath: \u0026quot;stylish-haskell\u0026quot; \u0026quot;.text.tex.latex.haskell\u0026quot;: \u0026quot;ide-haskell\u0026quot;: stylishHaskellPath: \u0026quot;hindent\u0026quot;  You can learn scope name for a given grammar by opening a file using that grammar and running editor:log-cursor-scope command. The first (topmost) entry in the message would be the root scope, the rest are syntax scopes.\nBear in mind ide-haskell isn\u0026rsquo;t sensitive to syntax scopes (since it\u0026rsquo;s either overly complicated to support or doesn\u0026rsquo;t make much sense).\nHere\u0026rsquo;s a list of settings that are sensitive to root scope:\n onSavePrettify onSavePrettifyFormats  source*c2hs source*cabal source*hsc2hs source*haskell text*tex*latex*haskell source*hsig  expressionTypeInterval onCursorMove stylishHaskellPath stylishHaskellArguments cabalPath  This list can be incomplete.\n "
},
{
	"uri": "https://atom-haskell.github.io/extra-packages/ide-haskell-hoogle/",
	"title": "IDE-Haskell-Hoogle",
	"tags": [],
	"description": "",
	"content": " Install package ide-haskell-hoogle. Refer to Atom Flight Manual for details on installing packages.\nPackage supports using either local Hoogle database, or remote one (hosted on https://haskell.org/hoogle/ and/or http://hoogle.haskell.org/)\n Local database requires hoogle executable, plus you will need to build hoogle database for hoogle itself to work. Remote database obviously requires connection to the Internet  Choosing remote or local database By default, package uses \u0026ldquo;new\u0026rdquo; remote database from http://hoogle.haskell.org/. You can change that using Hoogle Type setting:\nSetup for local database Install hoogle You can use cabal, stack, or your favorite package manager.\nCabal:\ncabal install hoogle  Stack:\nstack install hoogle  Build local hoogle database You can use either hoogle-4 or hoogle-5, either of these versions will work. However, hoogle-5 is recommended.\nIf not sure what hoogle version you have, run hoogle --version.\nYou should get output similar to this:\n$ hoogle --version Hoogle 5.0.12, http://hoogle.haskell.org/  or\n$ hoogle --version Hoogle v4.2.43, (C) Neil Mitchell 2004-2012 http://haskell.org/hoogle  Hoogle v4 You have a choice between installing basic database and extended database.\nInstalling extended database will take a lot of time and memory!\n To install basic database, run\nhoogle data  To install extended database, run\nhoogle data all  Hoogle v5 Run\nhoogle generate --download  This will get you the database used on http://haskell.org/hoogle\nPoint the package to hoogle executable You don\u0026rsquo;t need to do this if hoogle is in PATH, i.e. if you can type hoogle in the terminal, and won\u0026rsquo;t get \u0026lsquo;File not found\u0026rsquo; error.\n Open Atom\u0026rsquo;s settings, Packages, find ide-haskell-hoogle, then set Hoogle Path to full path to hoogle executable. For example, if your hoogle executable is located in /home/user/.local/bin/ directory, put /home/user/.local/bin/hoogle into Hoogle Path.\n"
},
{
	"uri": "https://atom-haskell.github.io/extra-packages/ide-haskell-repl/",
	"title": "IDE-Haskell-REPL",
	"tags": [],
	"description": "",
	"content": " This package provides a way to interact with ghci (or, alternatively, cabal repl or stack ghci) from Atom.\nRepl backend selection ide-haskell-repl will try to automatically select the correct repl backend (stack/cabal/ghci) based on current builder chosen in ide-haskell-cabal. You can choose none builder to use ghci in plain projects (a.k.a. projects with no *.cabal file).\nIf ide-haskell-cabal is unavailable (e.g. disabled), ide-haskell-repl will fall back to defaultRepl specified in settings.\nUsing on Windows On Windows, interrupting ghci will kill it. There is no good solution to this problem at the moment, but there is a \u0026ldquo;bad\u0026rdquo; solution.\nYou need to get ghci-wrapper.exe executable from https://github.com/atom-haskell/win-ghci-wrapper/releases (or if you don\u0026rsquo;t trust random binaries you\u0026rsquo;ve downloaded from the Internet, you can build it from source \u0026ndash; you only really need ghc for that)\nThen you need to specify full path to this executable in ghciWrapperPath setting of this package.\nFor example, if you placed ghci-wrapper.exe in C:\\Downloads directory, you need to put C:\\Downloads\\ghci-wrapper.exe in ghciWrapperPath setting.\nFinally, restart any open REPL sessions.\nRepl-specific commands To send command, or move through history, you can use the following commands when focused on repl command editor:\n ide-haskell-repl:exec-command ide-haskell-repl:history-back ide-haskell-repl:history-forward ide-haskell-repl:ghci-reload  Note that this commands are bound specifically to repl editor, which has CSS selector of atom-text-editor.ide-haskell-repl.\nYou can rebind those in your keymap, e.g.\n\u0026quot;atom-text-editor.ide-haskell-repl\u0026quot;: 'ctrl-enter': 'ide-haskell-repl:exec-command' 'ctrl-up': 'ide-haskell-repl:history-back' 'ctrl-down': 'ide-haskell-repl:history-forward'  Just don\u0026rsquo;t forget to disable default bindings in ide-haskell-repl settings, if you don\u0026rsquo;t want them.\n"
},
{
	"uri": "https://atom-haskell.github.io/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Chapter II Installation  Installing packages     Installing binary dependencies     "
},
{
	"uri": "https://atom-haskell.github.io/installation/installing-binary-dependencies/",
	"title": "Installing binary dependencies",
	"tags": [],
	"description": "",
	"content": " Supported ghc-mod versions are 5.6. and up.\n These instructions assume you want to use stylish-haskell as a prettifier. If you would like to use hindent or brittany instead, substitute that in place of stylish-haskell below.\nBear in mind that prettifier has to be able to work as a unix filter, i.e. accept input on STDIN and return output on STDOUT.\n The Atom-Haskell packages (and this instructions) assume that you have at least a minimal Haskell toolchain installed on your system. See https://www.haskell.org/downloads for your options.\nPlease bear in mind that ghc-mod doesn\u0026rsquo;t yet support GHC 8.2. See https://github.com/DanielG/ghc-mod/pull/911. If installing GHC separately, make sure to get GHC 8.0, otherwise, you might run into problems.\n This guide only touches on installing prettifier (like stylish-haskell) and ghc-mod (which you need for all the \u0026ldquo;good stuff\u0026rdquo;, like type tooltips and autocompletion). Extra packages, however, can have other binary dependencies. Installation procedure is rather similar, so no detailed guide is provided. Refer to requirements list for more information.\n With stack See also section on using haskell-ghc-mod with stack\n Probably a simpler way to start with is to build binary dependencies with stack. Refer to stack documentation to get more information about it.\nRun the following commands from a command line terminal after you get yourself a minimal Haskell toolchain (either via Haskell Platform, or with stack setup):\n$ stack install stylish-haskell ... Copied executables to {STACK_INSTALL_PATH}: - stylish-haskell $ stack install ghc-mod ... Copied executables to {STACK_INSTALL_PATH}: - ghc-mod - ghc-modi  \u0026hellip; where STACK_INSTALL_PATH depends on your operating system. For example, on OS X or Linux this path will usually be ~/.local/bin/.\nFirst, make sure that STACK_INSTALL_PATH is on your executable search path (i.e. $PATH for OS X and Linux).\nOn Linux, avoid setting PATH in .bashrc/.zshrc. These scripts are only executed in interactive shells, which means you\u0026rsquo;ll have to start Atom from terminal session for it to pick PATH up correctly.\n On OSX, Atom can fail to set PATH correctly regardles.\n If Atom fails to find a required executable (such as stylish-haskell) you will get an error that reads something like this:\n Ide-haskell could not spawn stylish-haskell\nError: spawn stylish-haskell ENOENT\n If this happens, you will need to modify relevant package\u0026rsquo;s settings to point to the absolute path to where you installed the executable. For example, if your STACK_INSTALL_PATH were /home/johndoe/.local/bin/ then the absolute path to the executable would be /home/johndoe/.local/bin/executable.\nA notable exception is haskell-ghc-mod package. Avoid setting \u0026lsquo;Ghc Mod Path\u0026rsquo; to anything but ghc-mod (i.e. plain executable name) if at all possible. Instead, add the directory containing ghc-mod executable to \u0026lsquo;Additional Path Directories\u0026rsquo;, so, using the example above, add /home/johndoe/.local/bin to \u0026lsquo;Additional Path Directories\u0026rsquo;.\n With cabal You do not need to do this if you already installed with stack.\n Alternatively, you can use cabal-install if you don\u0026rsquo;t want to use stack for some reason.\nIt is advisable to first create a cabal sandbox for the installation to avoid global package database pollution and conflicts. This will also make updating easy.\nTo create a sandbox, create a directory, f.ex.\nmkdir $HOME/ghc-mod-sandbox  Windows command line shell uses different syntax for environment variables, and there is usually no HOME defined anyway. We sincerely hope you can figure this out.\n Then, cd into int:\ncd $HOME/ghc-mod-sandbox  And run the following command\ncabal sandbox init --sandbox=.  The last part, namely --sandbox=., is used to shorten paths. By default, cabal will create sandbox in .cabal-sandbox directory. This option tells it to use current directory instead.\n If you decide not to use sandbox for some reason, by default cabal will install binaries into $HOME/.cabal/bin/ on Linux and $HOME/Library/Haskell/bin on OSX.\n Now you can install ghc-mod and stylish-haskell. In the same directory run\ncabal install ghc-mod stylish-haskell  Now you have ghc-mod and stylish-haskell installed. Binary files are in $HOME/ghc-mod-sandbox/bin. You can add this path to PATH, or put full path to executables in relevant ide-haskell settings and full path to directory in haskell-ghc-mod \u0026lsquo;Additional Path Directories\u0026rsquo;.\nFor example, assuming your HOME is /home/user:\n In ide-haskell settings, set \u0026lsquo;Stylish Haskell Path\u0026rsquo; to /home/user/ghc-mod-sandbox/bin/stylish-haskell In haskell-ghc-mod settings, set \u0026lsquo;Additional Path Directories\u0026rsquo; to /home/user/ghc-mod-sandbox/bin  Avoid setting \u0026lsquo;Ghc Mod Path\u0026rsquo; in haskell-ghc-mod settings to anything but ghc-mod (i.e. plain executable name) if at all possible. Instead, use \u0026lsquo;Additional Path Directories\u0026rsquo;.\n \u0026lsquo;Cabal Sandbox\u0026rsquo; option will make haskell-ghc-mod look for ghc-mod executable in the current project\u0026rsquo;s Cabal sandbox first, so if using Cabal sandboxes, you can install ghc-mod per-project.\n Don\u0026rsquo;t forget to replace $HOME with actual path to home directory! Atom doesn\u0026rsquo;t expand shell variables in package settings.\n On Linux and OSX, you can run echo $HOME/ghc-mod-sandbox/bin/* in the terminal to get actual paths to all executables, if not sure what those should look like.\n With Nix On NixOS, or with Nix package manager, Haskell binaries are available in the haskellPackages attribute set.\nYou can query the list of all available Haskell packages with: nix-env -f \u0026quot;\u0026lt;nixpkgs\u0026gt;\u0026quot; -qaP -A haskellPackages\n Install ghc-mod and stylish-haskell.\nnix-env -f \u0026quot;\u0026lt;nixpkgs\u0026gt;\u0026quot; -iA haskellPackages.ghc-mod haskellPackages.stylish-haskell  You should now have ghc-mod and stylish-haskell available in your profile.\n"
},
{
	"uri": "https://atom-haskell.github.io/core-packages/",
	"title": "Core Packages",
	"tags": [],
	"description": "",
	"content": " Chapter II Core Packages  Language-Haskell     IDE-Haskell     IDE-Haskell-Cabal     Haskell-ghc-mod     Autocomplete-Haskell     "
},
{
	"uri": "https://atom-haskell.github.io/core-packages/ide-haskell-cabal/",
	"title": "IDE-Haskell-Cabal",
	"tags": [],
	"description": "",
	"content": " The ide-haskell-cabal package provides a build backend for ide-haskell package based on cabal or stack.\nIt supports easy switching between multiple versions of GHC by having a set of configuration settings for each version of GHC, plus a drop-down box to pick a GHC version. For each GHC version you can specify:\n The path (either adding to your system path or replacing it completely) The sandbox file (cabal CABAL_SANDBOX_CONFIG environment variable) The build directory (cabal --builddir parameter). This defaults to dist/.  It also provides support for ide-haskell\u0026rsquo;s build target selection by reading and parsing the .cabal file and extracting the available targets (it uses a thin ghcjs-compiled wrapper around the Cabal library to read the .cabal file).\nKeybindings Ide-Haskell-Cabal comes with little pre-specified keybindings, so you will need to specify your own, if you want those.\nYou can edit Atom keybindings by opening Edit → Keymap\u0026hellip;. Here is a template for all commands, provided by ide-haskell-cabal:\n'atom-workspace': '': 'ide-haskell-cabal:build' '': 'ide-haskell-cabal:clean' '': 'ide-haskell-cabal:test' '': 'ide-haskell-cabal:bench' '': 'ide-haskell-cabal:build-dependencies' '': 'ide-haskell-cabal:set-build-target' '': 'ide-haskell-cabal:set-active-builder'  "
},
{
	"uri": "https://atom-haskell.github.io/overview/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " The Atom-Haskell packages assume that you have at least a minimal Haskell toolchain installed on your system. See https://www.haskell.org/downloads for your options.\nCore Atom-Haskell packages  language-haskell \u0026ndash; Syntax highlighting and Haskell autodetection ABSOLUTELY REQUIRED! ide-haskell \u0026ndash; GUI and minimal utilities ABSOLUTELY REQUIRED! ide-haskell-cabal \u0026ndash; Build Haskell projects with either cabal or stack. Reports errors/warnings on build. haskell-ghc-mod \u0026ndash; ghc-mod integration. Typecheck and lint sources without building, query type information and more. autocomplete-haskell \u0026ndash; Autocompletion support. This plugin depends on haskell-ghc-mod.  Extra Atom-Haskell packages  haskell-pointfree \u0026ndash; convert selection to pointfree/pointful representation ide-haskell-hasktags \u0026ndash; go to declaration, list all symbols defined in file/project ide-haskell-hoogle \u0026ndash; lookup hoogle documentation via local hoogle database ide-haskell-profiteurjs \u0026ndash; display GHC profiling results in Atom ide-haskell-repl \u0026ndash; GHCi REPL in Atom language-haskell-scoped \u0026ndash; highlight known identifiers in editor  Binary dependencies  stylish-haskell, hindent or brittany \u0026ndash; prettify/format your source code. Used by ide-haskell ghc-mod \u0026ndash; backend that does heavy lifting. Used by haskell-ghc-mod hasktags \u0026ndash; indexes your sources for easy navigation. Used by ide-haskell-hasktags (Optional) pointfree and pointful \u0026ndash; convert source to pointfree or pointful representation. Used by haskell-pointfree (Optional) hoogle \u0026ndash; Haskell API search engine. Used by ide-haskell-hoogle  "
},
{
	"uri": "https://atom-haskell.github.io/extra-packages/",
	"title": "Extra Packages",
	"tags": [],
	"description": "",
	"content": " Chapter III Extra Packages  IDE-Haskell-Hoogle     IDE-Haskell-REPL     "
},
{
	"uri": "https://atom-haskell.github.io/core-packages/haskell-ghc-mod/",
	"title": "Haskell-ghc-mod",
	"tags": [],
	"description": "",
	"content": " Haskell ghc-mod opens pipe to ghc-mod and queries types, info, typechecks and lints current file.\nWhen using with stack, see Using with stack\n Configuration Only configuration option you will likely need to set is additionalPathDirectories. It needs to be set to full path to the directory containing ghc-mod executable, if it is not in your PATH.\nFor example, if you have ghc-mod in /home/user/.cabal/bin/, you need to write /home/user/.cabal/bin in additionalPathDirectories. Note that shell expansions are not suported, i.e. you can\u0026rsquo;t use ~ or $HOME.\nYou really shouldn\u0026rsquo;t touch ghcModPath setting, unless you know precisely what you\u0026rsquo;re doing. If you specify full path there, Atom won\u0026rsquo;t be able to grab ghc-mod from stack or cabal sandbox!\n You may also consider adding path to directory containing ghc/ghci executable to additionalPathDirectories. The list is comma-separated. For example, if you have ghc executable installed to /usr/local/bin, then you could extend additionalPathDirectories to be /home/user/.cabal/bin,/usr/local/bin.\nKeybindings Haskell-ghc-mod comes with little pre-specified keybindings, so you will need to specify your own, if you want those.\nYou can edit Atom keybindings by opening \u0026lsquo;Edit → Open Your Keymap\u0026rsquo;. Here is a template for all commands, provided by haskell-ghc-mod:\n'atom-text-editor[data-grammar~=\u0026quot;haskell\u0026quot;]': '': 'haskell-ghc-mod:check-file' '': 'haskell-ghc-mod:lint-file' 'ctrl-alt-t': 'haskell-ghc-mod:show-type' #this is an example binding 'ctrl-alt-i': 'haskell-ghc-mod:show-info' #this is an example binding 'ctrl-alt-T': 'haskell-ghc-mod:insert-type' #this is an example binding '': 'haskell-ghc-mod:case-split' '': 'haskell-ghc-mod:sig-fill' '': 'haskell-ghc-mod:show-info-fallback-to-type' '': 'haskell-ghc-mod:show-type-fallback-to-info' '': 'haskell-ghc-mod:show-type-and-info' '': 'haskell-ghc-mod:insert-import' '': 'haskell-ghc-mod:go-to-declaration' 'atom-workspace': '': 'haskell-ghc-mod:shutdown-backend'  Advanced configuration In some cases, it could be useful to disable ghc-mod completely for a given project (e.g. GHCJS), or suppress error pop-ups (e.g. in case of known ghc-mod bugs where some features don\u0026rsquo;t work, or don\u0026rsquo;t always work).\nYou can create .haskell-ghc-mod.json file in project root (i.e. directory containing a *.cabal file, or \u0026ndash; in case of plain projects \u0026ndash; Atom\u0026rsquo;s project root directory).\n.haskell-ghc-mod.json from Atom project root will also be honored, if it exists, with lower priority.\nYou can also create a global config file in ${ATOM_CONFIG_DIR}/haskell-ghc-mod.json. ${ATOM_CONFIG_DIR} is usually ${HOME}/.atom, but you can check it\u0026rsquo;s path by running atom.getConfigDirPath() in Atom\u0026rsquo;s developer console (View → Developer → Toggle Developer Tools → Console).\nConfig file is a JSON file with the following fields:\n \u0026quot;disable\u0026quot; \u0026ndash; true/false. Will disable all ghc-mod functions entirely. If omitted, defaults to false. \u0026quot;suppressErrors\u0026quot; \u0026ndash; true/false. Will suppress error pop-ups. Those still will be displayed in Atom\u0026rsquo;s console (View → Developer → Toggle Developer Tools), so if someting seems wierd, one could check there. \u0026quot;ghcOptions\u0026quot; \u0026ndash; Array of Strings. Options to pass to GHC. Can be useful to explicitly suppress warnings, e.g. -fno-warn-unused-do-bind or anything else. \u0026quot;ghcModOptions\u0026quot; \u0026ndash; Array of Strings. Arbitrary options to pass to ghc-mod. Bear in mind that you shouldn\u0026rsquo;t really change most ghc-mod options, since the package makes some assumptions on that part. Also only global ghc-mod options will work (i.e. no command-specific ones)  Example:\n{ \u0026quot;disable\u0026quot;: false, \u0026quot;suppressErrors\u0026quot;: true, \u0026quot;ghcOptions\u0026quot;: [\u0026quot;-fno-warn-unused-do-bind\u0026quot;, \u0026quot;-fno-warn-name-shadowing\u0026quot;], \u0026quot;ghcModOptions\u0026quot;: [\u0026quot;--with-ghc\u0026quot;, \u0026quot;/path/to/custom/ghc\u0026quot;] }  Using with stack Stack support is limited. This section contains some tricks that can help to coerce ghc-mod into cooperation.\nDO NOT specify full path to ghc-mod/ghc-modi in haskell-ghc-mod settings. Do not add anything to \u0026lsquo;Additional Path Directories\u0026rsquo; as well, unless you need to (i.e. know what you\u0026rsquo;re doing). Make sure \u0026lsquo;Stack Sandbox\u0026rsquo; option is enabled (this is the default)\n Remove dist folder in project root Ghc-mod assumes you want to use cabal if it finds dist/setup-config in project root. In any case, if you want to use stack, you don\u0026rsquo;t need dist directory anyway (unless you\u0026rsquo;re using it to store sources, in which case, it\u0026rsquo;s strongly advised you don\u0026rsquo;t)\nMaintain a separate ghc-mod installation for each stack resolver Ghc-mod requires that it must be built with the same version of GHC that you use to build your project. In most cases this means that you need a separate ghc-mod installation for every distinct stack resolver you\u0026rsquo;re using.\nSimplest way to achieve this would be to install ghc-mod locally for every stack project you want to use it with, i.e. run stack build ghc-mod in project directory (if you have multiple stack.yaml configs, do this for each one). If this fails for some reason, try to use stack-installed ghc (with stack --no-system-ghc --install-ghc build ghc-mod). Note that some resolvers seemingly can\u0026rsquo;t build ghc-mod at all. You might also want to install newer ghc-mod version than a given resolver offers. Refer to stack documentation on how exactly you could do that.\nIf you enable \u0026lsquo;Stack Sandbox\u0026rsquo; in haskell-ghc-mod settings (enabled by default), and leave \u0026lsquo;Ghc Mod Path\u0026rsquo; as default ghc-mod (i.e. no actual path), Atom should automatically pick up local stack installation.\nWith lts-4.1 resolver (and probably later), you can also install ghc-mod into \u0026lsquo;global project\u0026rsquo; (essentially run stack build ghc-mod outside any project directory). This will automatically provide ghc-mod executables to all projects using this resolver (so you don\u0026rsquo;t need to install it per-project). Note this does not work with lts-3.22.\nLater stack versions (and resolvers) install packages per-resolver globally, regardless of if you run stack build ghc-mod in stack project directory or not. Not sure which version changed that, but stack 1.0.2 with lts-5.6 resolver does that.\nAvoid mixing stack- and cabal-installed packages This should go without saying. It\u0026rsquo;s always a bad idea to mix packages installed with stack and cabal-install. At least avoid mixing those in the same project, i.e. if you\u0026rsquo;re using stack, use stack-installed ghc-mod. If you\u0026rsquo;re using cabal-install, use cabal-installed ghc-mod. Yes, it is not exactly simple.\nRun Atom with stack exec atom (deprecated) This is a last-ditch workaround, is deprecated and can lead to unexpected problems.\nShould not be required with haskell-ghc-mod 1.6.0 and up. Please create issue if it doesn\u0026rsquo;t work\nThis can lead to ghc-mod complaining about GHC_PACKAGE_PATH, so avoid this workaround if at all possible\n Stack manages multiple ghc installations using environment hacking. So, in order to bring this environment into scope when using Atom, the most straightforward way is to run Atom with stack exec atom from project directory. Under Windows it will be something like: stack exec \u0026quot;%USERPROFILE%\\AppData\\Local\\atom\\app-1.7.3\\atom.exe\u0026quot;\n"
},
{
	"uri": "https://atom-haskell.github.io/core-packages/autocomplete-haskell/",
	"title": "Autocomplete-Haskell",
	"tags": [],
	"description": "",
	"content": "Autocomplete-haskell provides autocompletion facilities for your Haskell hacking. It relies on scope names provided by language-haskell and haskell-completion-backend service, provided by haskell-ghc-mod\nYou can show auto-completions for hole _. This will try to find replacements based on type. It\u0026rsquo;s no magic though, so if hole has some crazy type, it won\u0026rsquo;t find anything. You can also refine hole completions based on name by using named holes, e.g. _from\nSadly, it does not pick up types and/or other symbols defined in current file (ghc-mod seems to be incapable of this feat), so for this you have to rely on default autocomplete-plus SymbolProvider.\n"
},
{
	"uri": "https://atom-haskell.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://atom-haskell.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]