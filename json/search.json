[
    {
        "uri": "/content/_index",
        "title": "Atom-Haskell documentation",
        "content": "\nWelcome to Atom-Haskell documentation site.\n\nInformation collected on these pages should help you get started with Haskell in Atom editor.\n\nAt the moment, this site mostly only collects information from various Atom-Haskell project READMEs. Proper documentation/tutorials are work-in-progress.\n\nClick one of the links on the left to start reading.\n\nIRC Chat\n\nYou can join atom-haskell on FreeNode, and devs can usually be found there. Bear in mind that if someone's on the channel, it doesn't necessarily mean they aren't AFK.\n\nIf you're not familiar with IRC, you can use FreeNode's webchat\n",
        "tags": []
    },
    {
        "uri": "/content/core-packages/autocomplete-haskell",
        "title": "Autocomplete-Haskell",
        "content": "\nAutocomplete-haskell provides autocompletion facilities for your Haskell\nhacking.\nIt relies on scope names provided by language-haskell and haskell-completion-backend service, provided by haskell-ghc-mod\n\nYou can show auto-completions for hole _. This will try to find replacements\nbased on type. It's no magic though, so if hole has some crazy type, it won't\nfind anything. You can also refine hole completions based on name by using named holes, e.g. _from\n\nSadly, it does not pick up types and/or other symbols defined in current file\n(ghc-mod seems to be incapable of this feat), so for this you have to rely on\ndefault autocomplete-plus SymbolProvider.\n",
        "tags": []
    },
    {
        "uri": "/content/core-packages/haskell-ghc-mod",
        "title": "Haskell-ghc-mod",
        "content": "\nHaskell ghc-mod opens pipe to ghc-mod and queries types, info, typechecks and lints current file.\n\n{{%notice warning%}}\nWhen using with stack, see https://github.com/atom-haskell/haskell-ghc-mod/wiki/Using-with-stack\n{{%/notice%}}\n\nConfiguration\n\nOnly configuration option you will likely need to set is ghcModPath. It needs to be set to full path to ghc-mod executable, if it is not in your PATH. For example, if you have ghc-mod in /home/user/.cabal/bin/, you need to write /home/user/.cabal/bin/ghc-mod in ghcModPath. Note that shell expansions are not suported, i.e. you can't use ~ or $HOME.\n\nYou may also consider adding path to directory containing ghc/ghci executable to\nadditionalPathDirectories configuration option. It is a comma-separated list\nof directories that will be added to your search path when invoking ghc-mod.\nFor example, if you have ghc installed to /usr/local, then you would add\n/usr/local/bin to additionalPathDirectories.\n\n Keybindings\n\nHaskell-ghc-mod comes with little pre-specified keybindings, so you will need to specify your own, if you want those.\n\nYou can edit Atom keybindings by opening 'Edit → Open Your Keymap'. Here is a template for all commands, provided by haskell-ghc-mod:\n\n'atom-text-editor[data-grammar~=\"haskell\"]':\n  '': 'haskell-ghc-mod:check-file'\n  '': 'haskell-ghc-mod:lint-file'\n  'ctrl-alt-t': 'haskell-ghc-mod:show-type' #this is an example binding\n  'ctrl-alt-i': 'haskell-ghc-mod:show-info' #this is an example binding\n  'ctrl-alt-T': 'haskell-ghc-mod:insert-type' #this is an example binding\n  '': 'haskell-ghc-mod:case-split'\n  '': 'haskell-ghc-mod:sig-fill'\n  '': 'haskell-ghc-mod:show-info-fallback-to-type'\n  '': 'haskell-ghc-mod:show-type-fallback-to-info'\n  '': 'haskell-ghc-mod:show-type-and-info'\n  '': 'haskell-ghc-mod:insert-import'\n  '': 'haskell-ghc-mod:go-to-declaration'\n\n'atom-workspace':\n  '': 'haskell-ghc-mod:shutdown-backend'\n\nAdvanced configuration\n\nIn some cases, it could be useful to disable ghc-mod completely for a given project (e.g. GHCJS), or suppress error pop-ups (e.g. in case of known ghc-mod bugs where some features don't work, or don't always work).\n\nYou can create .haskell-ghc-mod.json file in project root (i.e. directory containing a *.cabal file, or -- in case of plain projects -- Atom's project root directory).\n\n.haskell-ghc-mod.json from Atom project root will also be honored, if it exists, with lower priority.\n\nYou can also create a global config file in ${ATOMCONFIGDIR}/haskell-ghc-mod.json. ${ATOMCONFIGDIR} is usually ${HOME}/.atom, but you can check it's path by running atom.getConfigDirPath() in Atom's developer console (View → Developer → Toggle Developer Tools → Console).\n\nConfig file is a JSON file with the following fields:\n\n\"disable\" -- true/false. Will disable all ghc-mod functions entirely. If omitted, defaults to false.\n\"suppressErrors\" -- true/false. Will suppress error pop-ups. Those still will be displayed in Atom's console (View → Developer → Toggle Developer Tools), so if someting seems wierd, one could check there.\n\"ghcOptions\" -- Array of Strings. Options to pass to GHC. Can be useful to explicitly suppress warnings, e.g. -fno-warn-unused-do-bind or anything else.\n\"ghcModOptions\" -- Array of Strings. Arbitrary options to pass to ghc-mod. Bear in mind that you shouldn't really change most ghc-mod options, since the package makes some assumptions on that part. Also only global ghc-mod options will work (i.e. no command-specific ones)\n\nExample:\n\n{\n  \"disable\": false,\n  \"suppressErrors\": true,\n  \"ghcOptions\": [\"-fno-warn-unused-do-bind\", \"-fno-warn-name-shadowing\"],\n  \"ghcModOptions\": [\"--with-ghc\", \"/path/to/custom/ghc\"]\n}\n",
        "tags": []
    },
    {
        "uri": "/content/core-packages/ide-haskell-cabal",
        "title": "IDE-Haskell-Cabal",
        "content": "\nThe ide-haskell-cabal package provides a build backend for ide-haskell\npackage based on cabal or stack.\n\nIt supports easy switching between multiple versions of GHC by having a set of configuration settings for each version of GHC, plus a drop-down box to pick a GHC version. For each GHC version you can specify:\n\nThe path (either adding to your system path or replacing it completely)\nThe sandbox file (cabal CABALSANDBOXCONFIG environment variable)\nThe build directory (cabal --builddir parameter). This defaults to dist/.\n\nIt also provides support for ide-haskell's build target selection by reading and parsing the .cabal file and extracting the available targets (it uses a thin ghcjs-compiled wrapper around the Cabal library to read the .cabal file).\n\nKeybindings\n\nIde-Haskell-Cabal comes with little pre-specified keybindings, so you will need to specify your own, if you want those.\n\nYou can edit Atom keybindings by opening Edit → Keymap.... Here is a template for all commands, provided by ide-haskell-cabal:\n\n'atom-workspace':\n  '': 'ide-haskell-cabal:build'\n  '': 'ide-haskell-cabal:set-build-target'\n  '': 'ide-haskell-cabal:clean'\n  '': 'ide-haskell-cabal:test'\n",
        "tags": []
    },
    {
        "uri": "/content/core-packages/ide-haskell",
        "title": "IDE-Haskell",
        "content": "\nIDE-Haskell Atom package provides basic capabilities, as well as a backend for other Atom-Haskell packages to use.\n\nKnown conflicts\n\nThis package relies on grammar defined by language-haskell. Any other Haskell grammar packages (such as haskell-grammar) may conflict with it.\n\n Configuration\n\nPackage is fully configurable via **Edit → Preferences → Packages → ide-haskell\n→ Settings**\n\nYou will likely need to specify full path to stylish-haskell, if it is not in\nyour PATH, at the very least.\n\nYou might also want to look into configuring haskell-ghc-mod (haskell-ghc-mod README) and ide-haskell-cabal (ide-haskell-cabal README)\n\n{{%notice note%}}\nSince version 1.0.0, some configuration options have been moved to\nbackends, in particular, haskell-ghc-mod. Migration should be automatic, but\nplease check if your configuration is correct just in case.\n{{%/notice%}}\n\nKeyboard shortcuts\n\n{{%notice note%}}\nSince version 1.0.0, most commands are provided by\nbackends, in particular, haskell-ghc-mod and ide-haskell-cabal. Please revise\nyour keymap accordingly.\n{{%/notice%}}\n\nRefer to (haskell-ghc-mod README) and (ide-haskell-cabal README) for details\n\nIde-Haskell comes with little pre-specified keybindings, so you will need to specify your own, if you want those.\n\nYou can edit Atom keybindings by opening 'Edit → Open Your Keymap'. Here is a template for all commands, provided by ide-haskell:\n\n'atom-text-editor[data-grammar~=\"haskell\"]':\n  'escape': 'ide-haskell:close-tooltip' this is set by default\n  '':'ide-haskell:prettify-file'\n  '':'ide-haskell:next-error'\n  '':'ide-haskell:prev-error'\n\n'atom-text-editor[data-grammar~=\"cabal\"]':\n  '': 'ide-haskell:prettify-file'\n\n'atom-workspace':\n  '': 'ide-haskell:toggle-output'\n\nChanging output panel look\n\nChanging output panel look can be achieved with Atom stylesheets. You can open your stylesheet with Edit → Stylesheet...\n\nSyntax is Less. You can use the following selectors:\n\nide-haskell-panel -- whole panel\nide-haskell-panel-heading -- panel heading (control elements)\nide-hashell-panel-items -- output area\nide-haskell-item-position -- file/line/column of individual message\nide-haskell-item-description -- message itself\n\nPlease note, that to change font face in ide-haskell-item-description, you need to target it specifically, or use !important specifier.\n\nFor example, to change font size in whole panel:\n\nide-haskell-panel {\n  font-size: 18pt;\n}\n\nOr only in output area:\n\nide-haskell-panel-items {\n  font-size: 18pt;\n}\n\nTo change font face in panel heading:\n\nide-haskell-panel-heading {\n  font-family: \"Comic Sans MS\";\n}\n\nTo change font face in messages themselves:\n\nide-haskell-item-description {\n  font-family: \"Fira Mono\";\n}\n\nYou are free to write any CSS, of course. Bear in mind, however, that any selectors not listed above are subject to sudden change.\n\n Using atom-linter for output\n\nYou can use linter package for displaying some messages. Install linter package, and then change messageDisplayFrontend in ide-haskell settings to linter. Restart Atom.\n",
        "tags": []
    },
    {
        "uri": "/content/core-packages/index",
        "title": "Core Packages",
        "content": "\nChapter II\n\n Packages\n\nA detailed overview of Atom-Haskell packages.\n",
        "tags": []
    },
    {
        "uri": "/content/core-packages/language-haskell",
        "title": "Language-Haskell",
        "content": "\nLanguage-Haskell adds syntax highlighting and snippets to Haskell files in Atom.\n\nAuto-indent\n\nIf you don't like current auto-indentation settings, you can define your own regular expression in config.cson (Edit - Open Your Config), or disable it altogether.\n\n{{%notice note%}}\nAtom is using oniguruma for regular expression, and, as such, expressionhas to be a string, not a javascript regexp. You'll also have to escape \\.\n{{%/notice%}}\n\nTo disable auto-indent:\n\n\".haskell.source\":\n  editor:\n    increaseIndentPattern: ''\n\nBy default, increaseIndentPattern has the following value:\n\n\".haskell.source\":\n  editor:\n    increaseIndentPattern: '(((=|\\\\bdo|\\\\bwhere|\\\\bthen|\\\\belse|\\\\bof)\\\\s)|(\\\\bif(?!.\\\\bthen\\\\b.\\\\belse\\\\b.).*))$'\n\n Configuring highlighting\n\n{{%notice tip%}}\nYou may need to reopen currently opened files (or restart Atom) for your new stylesheet to be applied.\n{{%/notice%}}\n\nModule names\n\nlanguage-haskell uses support.other.module.haskell scope for module names, both in import statements and when using qualified identifiers (like Prelude.foldl). Your syntax theme might not support this scope. If you want to highlight module names in this case, you can add the following to your stylesheet (Edit → Stylesheet...):\n\n.syntax--support.syntax--other.syntax--module.syntax--haskell {\n  color: C0A077; //or whatever color you like\n}\n\nOperators and infix function application\n\nlanguage-haskell uses keyword.operator.haskell scope for operators and keyword.operator.infix.haskell for infix function application, e.g.\n\nnegate map [1..10]\n\nNot all syntax themes support these scopes (almost none support keyword.operator.infix particularly)\n\nIf you want to higlight operators and infix function applications you can add the following to your stylesheet (Edit → Stylesheet...):\n\n.syntax--keyword.syntax--operator.syntax--haskell {\n  color: CF8C00; // or whatever color you like\n}\n.syntax--keyword.syntax--operator.syntax--infix.syntax--haskell {\n  color: #CC77AC; // if you want to highlight infix application differently\n}\n\nSpecial Prelude treatment\n\nFor historical and other reasons (see 85 for discussion), Prelude identifiers (functions, types, etc) are treated slightly differently and, depending on your highlighting theme, can be highlighted differently.\n\nScopes that are used:\n\nsupport.function.prelude.haskell for functions and values\nsupport.class.prelude.haskell for types\nentity.other.inherited-class.prelude.haskell for typeclasses\nsupport.tag.prelude.haskell for type constructors\n\nIf you want Prelude identifiers highlighted differently from all the rest, you can define different colors for all or some of those, f.ex. by adding something like this to your stylesheet (Edit → Stylesheet...):\n\n.syntax--support.syntax--function.syntax--prelude.syntax--haskell {\n  color: #56b6c2; // or whatever color you like\n}\n.syntax--support.syntax--tag.syntax--prelude.syntax--haskell {\n  color: #e9969d;\n}\n\nIf you don't want Prelude identifiers highlighted differently, you can override it by adding something like this to your stylesheet (Edit → Stylesheet...):\n\n.syntax--prelude.syntax--haskell {\n  color: inherit;\n}\n",
        "tags": []
    },
    {
        "uri": "/content/extra-packages/ide-haskell-hoogle",
        "title": "IDE-Haskell-Hoogle",
        "content": "\n\nInstall package ide-haskell-hoogle. Refer to Atom Flight Manual for details on installing packages.\n\nPackage requires hoogle executable, plus you will need to build hoogle database for hoogle itself to work.\n\nSetup\n\n Install hoogle\n\nYou can use cabal, stack, or your favorite package manager.\n\nCabal:\ncabal install hoogle\n\nStack:\nstack install hoogle\n\nBuild local hoogle database\n\nYou have a choice between installing basic database and extended database.\n\n{{%notice warning%}}\nInstalling extended database will take a lot of time and memory!\n{{%/notice%}}\n\nTo install basic database, run\nhoogle data\n\nTo install extended database, run\nhoogle data all\n\n Point the package to hoogle executable\n\n{{%notice info%}}\nYou don't need to do this if hoogle is in PATH, i.e. if you can type hoogle in the terminal, and won't get 'File not found' error.\n{{%/notice%}}\n\nOpen Atom's settings, Packages, find ide-haskell-hoogle, then set Hoogle Path to full path to hoogle executable. For example, if your hoogle executable is located in /home/user/.local/bin/ directory, put /home/user/.local/bin/hoogle into Hoogle Path.\n",
        "tags": []
    },
    {
        "uri": "/content/extra-packages/index",
        "title": "Extra Packages",
        "content": "\nChapter III\n\n Extra Packages\n",
        "tags": []
    },
    {
        "uri": "/content/installation/index",
        "title": "Installation",
        "content": "\nChapter II\n\n Installation\n",
        "tags": []
    },
    {
        "uri": "/content/installation/installing-binary-dependencies",
        "title": "Installing binary dependencies",
        "content": "\n{{%notice info%}}\nSupported ghc-mod versions are 5.6. and up.\n{{%/notice%}}\n\nWith stack\n\nThe most reliable way to build these executable binaries is to use\nstack install.\n\nRun the following commands from a command line terminal after you finish\ninstalling the minimal Haskell toolchain:\n\n$ stack install stylish-haskell\n...\nCopied executables to {STACKINSTALLPATH}:\nstylish-haskell\n$ stack install ghc-mod\n...\nCopied executables to {STACKINSTALLPATH}:\nghc-mod\nghc-modi\n\n... where STACKINSTALLPATH depends on your operating system.  For example,\non OS X or Linux this path will usually be ~/.local/bin/.\n\nFirst, make sure that STACKINSTALLPATH is on your executable search path\n(i.e. $PATH for OS X and Linux).\n\n{{% notice warning %}}\nOn Linux, avoid setting PATH in .bashrc/.zshrc. These scripts are only executed in interactive shells, which means you'll have to start Atom from terminal session for it to pick PATH up correctly.\n{{% /notice %}}\n\n{{% notice warning %}}\nOn OSX, Atom can fail to set PATH correctly regardles.\n{{% /notice %}}\n\nIf Atom fails to find a required executable (such as stylish-haskell) you will\nget an error that reads something like this:\n\n Ide-haskell could not spawn stylish-haskell\n\n Error: spawn stylish-haskell ENOENT\n\nIf this happens, you will need to modify relevant package's settings to point to the absolute path to where you installed the executable.  For example,\nif your STACKINSTALLPATH were /home/johndoe/.local/bin/ then the\nabsolute path to the executable would be\n/home/johndoe/.local/bin/executable.\n\n With cabal\n\n{{%notice info%}}\nYou do not need to do this if you already installed with stack.\n{{%/notice%}}\n\nAlternatively, you can use cabal-install if you don't want to use stack for some reason.\n\nIt is advisable to first create a cabal sandbox for the installation to avoid global package database pollution and conflicts. This will also make updating easy.\n\nTo create a sandbox, create a directory, f.ex.\n\nmkdir $HOME/ghc-mod-sandbox\n\n{{%notice info%}}\nWindows command line shell uses different syntax for environment variables, and there is usually no HOME defined anyway. We sincerely hope you can figure this out.\n{{%/notice%}}\n\nThen, cd into int:\n\ncd $HOME/ghc-mod-sandbox\n\nAnd run the following command\n\ncabal sandbox init --sandbox=.\n\n{{%notice tip%}}\nThe last part, namely --sandbox=., is used to shorten paths. By default, cabal will create sandbox in .cabal-sandbox directory. This option tells it to use current directory instead.\n{{%/notice%}}\n\n{{%notice tip%}}\nIf you decide not to use sandbox for some reason, by default cabal will install binaries into $HOME/.cabal/bin/ on Linux and $HOME/Library/Haskell/bin on OSX.\n{{%/notice%}}\n\nNow you can install ghc-mod and stylish-haskell. In the same directory run\n\ncabal install ghc-mod stylish-haskell\n\nNow you have ghc-mod and stylish-haskell installed. Binary files are in $HOME/ghc-mod-sandbox/bin. You can add this path to PATH, or put full path to executables in relevant ide-haskell and haskell-ghc-mod settings.\n\nFor example, assuming your HOME is /home/user:\n\nIn ide-haskell settings, set 'Stylish Haskell Path' to /home/user/ghc-mod-sandbox/bin/stylish-haskell\nIn haskell-ghc-mod settings, set 'Ghc Mod Path' to /home/user/ghc-mod-sandbox/bin/ghc-mod\n\n{{%notice warning%}}\nDon't forget to replace $HOME with actual path to home directory! Atom doesn't expand shell variables in package settings.\n{{%/notice%}}\n\n{{%notice tip%}}\nOn Linux and OSX, you can run\necho $HOME/ghc-mod-sandbox/bin/*\nin the terminal to get actual paths to all executables, if not sure what those should look like.\n{{%/notice%}}\n",
        "tags": []
    },
    {
        "uri": "/content/overview/features",
        "title": "Features",
        "content": "\nSytnax highlighting\n\nGrammars:\n\nHaskell (\\*.hs)\nLiterate Haskell (\\*.lhs)\nCabal (\\*.cabal)\n\n Errors, warnings and lints\n\nAfter saving the current file the check and linter processes will be executed.\nAfter processes are finished, the results can be seen in output panel. You can\nsee different kind of results by switching Errors, Warnings and Lints tab\nbuttons. If you click on message's file name in output panel, Atom will open\nthis file and put cursor near problem that triggered output message.\n\nCheck results can also be seen in left editor gutter (near line numbers) as\nicons. If you hover mouse pointer over such an icon, a tooltip will be shown\nwith problem description. Results are highlighted inside editor as well, so you\ncan easily determine where the problem is.\n\nGet type/info\n\nIf you have haskell-ghc-mod or similar package installed, you can get type of any expression and get info on any symbol.\n\nThere are two options to do so.\n\nFirst one is to hover mouse pointer over any Haskell source in editor, or any\nselection. By default, this will show type for expression/selecton under cursor.\nYou can change this behavior to show info for symbol, or disable it completely\nin IDE-Haskell settings.\n\nAnother option is to use keyboard to get type/info under cursor. No default\nbindings are specified, but you can specify them in your Atom keymap.\n\nSee Configuration for more information.\n\n Autocompletion\n\nYou can show auto-completions for hole _. This will try to find replacements\nbased on type. It's no magic though, so if hole has some crazy type, it won't\nfind anything. You can also refine hole completions based on name by using named holes, e.g. _from\n\nCurrent autocompletion scopes:\n\nImport module name\nImport module symbols\nLanguage pragmas\nOPTIONS_GHC pragma\nType name\nClass name\nSymbol name\n\nAutocompletion:\n\nImport autocompletion:\n\nHole autocompletion:\n\nCode beautify\n\nYou can use stylish-haskell utility to indent pragmas, imports and data type\ndefinitions. Simply select Prettify from Haskel IDE menu to apply\nstylish-haskell to current file.\n\n Build and test project\n\nIf you have ide-haskell-cabal or similar package installed, you can build,\nclean and test your project from ide-haskell (stack and cabal supported)\n",
        "tags": []
    },
    {
        "uri": "/content/overview/index",
        "title": "Overview",
        "content": "\nChapter I\n\n Overview\n\nWelcome to Atom-Haskell project! We aim to bring awesome Haskell support to the amazing Atom editor.\n",
        "tags": []
    },
    {
        "uri": "/content/overview/requirements",
        "title": "Requirements",
        "content": "\nThe Atom-Haskell packages assume that you have a minimal Haskell toolchain\ninstalled on your system. You can install this toolchain by following the\ninstructions here:\n\nMinimal Haskell installers\n\nCore Atom-Haskell packages\n\nlanguage-haskell -- Syntax highlighting and Haskell autodetection ABSOLUTELY REQUIRED!\nide-haskell -- GUI and minimal utilities ABSOLUTELY REQUIRED!\nide-haskell-cabal -- Build Haskell projects with either cabal or stack. Reports errors/warnings on build.\nhaskell-ghc-mod -- ghc-mod integration. Typecheck and lint sources without building, query type information and more.\nautocomplete-haskell -- Autocompletion support. This plugin depends on haskell-ghc-mod.\n\n Extra Atom-Haskell packages\n\nhaskell-pointfree -- convert selection to pointfree/pointful representation\nide-haskell-hasktags -- go to declaration, list all symbols defined in file/project\nide-haskell-hoogle -- lookup hoogle documentation via local hoogle database\nide-haskell-profiteurjs -- display GHC profiling results in Atom\nide-haskell-repl -- GHCi REPL in Atom\nlanguage-haskell-scoped -- highlight known identifiers in editor\n\nBinary dependencies\n\nstylish-haskell or hindent -- prettify/format your source code. Used by ide-haskell\nghc-mod -- backend that does heavy lifting. Used by haskell-ghc-mod\nhasktags -- indexes your sources for easy navigation. Used by ide-haskell-hasktags (Optional)\npointfree and pointful -- convert source to pointfree or pointful representation. Used by haskell-pointfree\nhoogle -- Haskell API search engine. Used by ide-haskell-hoogle\n",
        "tags": []
    }
]